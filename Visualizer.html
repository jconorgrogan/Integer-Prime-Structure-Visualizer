<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integer Prime Structure Visualizer - Enhanced with Insights</title>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        /* --- Root Variables --- */
        :root {
            --primary-color: #4285F4;    /* ISG / Blue */
            --secondary-color: #34A853;  /* DFG / Green */
            --tertiary-color: #FBBC05;   /* OmegaOmega / Yellow */
            --quaternary-color: #EA4335; /* Combined / Red */
            --lambda-pos-color: #1a73e8; /* Color for lambda = +1 */
            --lambda-neg-color: #d93025; /* Color for lambda = -1 */
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --light-text: #fff;
            --border-color: #dee2e6;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --border-radius: 8px;
        }

        /* --- Basic Reset & Body --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--dark-text);
            background-color: var(--light-bg);
            padding: 20px;
        }

        /* --- Main Container & Header --- */
        .container {
            max-width: 1700px;
            margin: 0 auto;
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--shadow);
        }

        header {
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: 600;
        }

        .description {
            font-size: 1.05rem;
            color: #6c757d;
            max-width: 950px;
            margin: 0 auto 20px auto;
        }

        /* --- Conceptual Framework Section --- */
        .conceptual-framework {
            background-color: #eef4ff; /* Light blue background */
            border: 1px solid #a8c7fa;
            border-radius: var(--border-radius);
            padding: 20px 25px;
            margin-bottom: 30px;
        }

        .conceptual-framework h2 {
            color: var(--primary-color);
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 1px solid #cddcff;
            padding-bottom: 10px;
            font-weight: 600;
        }

        .conceptual-framework p {
            margin-bottom: 10px;
            font-size: 1rem;
            color: #334;
        }

        .conceptual-framework strong,
        .conceptual-framework .concept { /* Added .concept class */
            font-weight: 600;
            color: #1a237e; /* Darker blue */
        }

        .conceptual-framework ul {
            list-style-position: inside;
            padding-left: 5px;
            margin-top: 5px;
        }

        .conceptual-framework li {
            margin-bottom: 5px;
        }

        /* --- Control Panel --- */
        .control-panel {
            background-color: #fdfdfd;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            align-items: start;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
            margin-bottom: 3px;
            color: #495057;
            font-size: 0.9rem;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        input,
        select,
        button {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.95rem;
            height: 38px;
        }

        input[type="text"],
        input[type="number"] {
            flex-grow: 1;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.15);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            font-weight: 500;
            min-width: 90px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        button:hover {
            background-color: #3367D6;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
            box-shadow: none;
        }

        #range-hint {
            margin-top: 5px;
            font-size: 0.8rem;
            color: #6c757d;
        }

        #range-error-message {
            color: red;
            font-size: 0.8rem;
            margin-top: 5px;
            min-height: 1.2em; /* Reserve space */
        }

        /* --- Visualization Layout --- */
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .view-container {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .view-info {
            flex-grow: 1;
            border-left: 5px solid var(--primary-color);
            padding-left: 10px;
        }

        .view-info h3 {
            margin-bottom: 5px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .view-info p {
            margin-bottom: 3px;
            font-size: 0.85rem;
            color: #495057;
        }

        .view-info .axis-desc {
            font-weight: 600;
            color: #333;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
        }

        .view-controls label {
            margin-right: 3px;
        }

        .view-controls select {
            padding: 2px 4px;
            height: auto;
            font-size: 0.8rem;
        }

        .view-header.isg .view-info { border-left-color: var(--primary-color); }
        .view-header.dfg .view-info { border-left-color: var(--secondary-color); }
        .view-header.omegaomega .view-info { border-left-color: var(--tertiary-color); }
        .view-header.combined .view-info { border-left-color: var(--quaternary-color); }

        .stats-display {
            font-size: 0.8rem;
            padding: 5px 15px;
            background-color: #e9f2ff;
            border-bottom: 1px solid var(--border-color);
        }

        .stats-display p {
            margin: 2px 0;
        }

        .visualization-container {
            width: 100%;
            min-height: 400px;
            height: 50vh;
            max-height: 550px;
            overflow: hidden;
            position: relative;
            background-color: white;
        }

        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.1rem;
            color: #6c757d;
            display: none;
            z-index: 10;
        }

        /* --- Factor Panel --- */
        .factor-panel {
            margin-top: 30px;
            padding: 25px;
            background-color: white;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        .factor-panel h2 {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            font-size: 1.5rem;
            font-weight: 600;
        }

        #factor-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
        }

        .factor-group {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid #eee;
        }

        .factor-group h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .factor-group p {
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .sup {
            vertical-align: super;
            font-size: smaller;
        }

        /* --- Mathematical Insights Section --- */
        .insights-section {
            margin-top: 40px;
            padding: 25px;
            background-color: #f1f3f5;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        .insights-section h2 {
            font-size: 1.6rem;
            color: var(--dark-text);
            margin-bottom: 20px;
            border-bottom: 1px solid #ced4da;
            padding-bottom: 10px;
            font-weight: 600;
        }

        details {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 15px;
            padding: 15px;
            transition: box-shadow 0.2s ease;
        }

        details[open] {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.06);
        }

        summary {
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            color: var(--primary-color);
            list-style: none;
            position: relative;
            padding-left: 25px;
        }

        summary::-webkit-details-marker { display: none; }
        summary::marker { display: none; }

        summary::before {
            content: '►';
            position: absolute;
            left: 0;
            top: 0px;
            font-size: 0.9em;
            color: var(--primary-color);
            transition: transform 0.2s ease;
        }

        details[open] summary::before {
            transform: rotate(90deg);
        }

        .insight-content {
            margin-top: 15px;
            padding-left: 25px;
            border-left: 2px solid #e0e0e0;
        }

        .insight-content h4 {
            margin-top: 15px;
            margin-bottom: 5px;
            font-size: 1rem;
            color: #333;
            font-weight: 600;
        }

        .insight-content p {
            margin-bottom: 10px;
            font-size: 0.95rem;
            line-height: 1.7;
        }

        .insight-content code {
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: Consolas, Monaco, monospace;
            font-size: 0.9em;
        }

        .emphasis {
            font-style: italic;
            color: #555;
        }

        .view-ref {
            font-weight: bold;
            font-size: 0.9em;
            color: #666;
            display: block;
            margin-bottom: 10px;
        }

        .concept-highlight {
            font-weight: bold;
            color: var(--secondary-color);
        }

        /* --- Responsive --- */
        @media (max-width: 1200px) {
            .visualization-grid {
                grid-template-columns: 1fr;
            }
            .visualization-container {
                height: 45vh;
                min-height: 350px;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            .description {
                font-size: 1rem;
            }
            .control-panel {
                grid-template-columns: 1fr;
            }
            #factor-details {
                grid-template-columns: 1fr;
            }
            .insights-section h2 {
                font-size: 1.4rem;
            }
            summary {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Integer Prime Structure Visualizer</h1>
            <p class="description">
                Explore the structure of integers via their prime factorizations. Map integers to coordinates based on exponent patterns (Intensity, Volume, Variety) revealing mathematical relationships, statistical distributions, and connections to number theory concepts like ζ(s) and λ(n). Includes 2D views and a combined 3D perspective.
            </p>
        </header>

        <section class="conceptual-framework">
            <h2>Conceptual Framework: Numbers as Relational Structures</h2>
            <p>This visualizer explores integers not just as quantities, but as unique structures defined by their prime factorization (e.g., 12 = 2² × 3¹). Think of each integer as a specific <span class="concept">"Pattern of Relatedness"</span> built from prime components.</p>
            <p>The core structural aspects derived from the factorization's exponents (e.g., the '2' and '1' for 12) are:</p>
            <ul>
                <li><span class="concept">Variety</span> (`ω(n)`): The number of <strong>unique prime things</strong> it's made of.</li>
                <li><span class="concept">Relative Mix/Pattern</span> (`{eᵢ}`): How many times each unique thing is used/stacked. Key summary:
                    <ul><li><strong>Peak Usage</strong> (`max{eᵢ}`): The highest stack height for any single prime type.</li></ul>
                </li>
                <li><span class="concept">Overall Structural Size</span> (`Ω(n)`): The grand total count of prime factors (Σeᵢ), reflecting both variety and usage pattern.</li>
            </ul>
            <p>The different visualization views map these structures by comparing pairs of these aspects, revealing <span class="concept">"meta-relationships"</span> – the underlying rules and patterns connecting different integer structures.</p>
        </section>

        <div class="control-panel">
            <div class="control-group">
                <label for="integer-input">Integer(s) Range:</label>
                <div class="input-group">
                    <input type="text" id="integer-input" placeholder="e.g. 1-100" value="1-100">
                    <button id="visualize-btn">Visualize</button>
                </div>
                <div id="range-hint">Range (e.g., 1-1000). Max: 5000.</div>
                <div id="range-error-message"></div>
            </div>
            <div class="control-group">
                <label for="highlight-input">Highlight Integer (Click Point or Enter):</label>
                <input type="number" id="highlight-input" min="1" placeholder="e.g. 12" value="12">
            </div>
            <div class="control-group">
                <label for="special-category">Highlight Category:</label>
                <select id="special-category">
                    <option value="none">None</option>
                    <option value="primes">Prime Numbers</option>
                    <option value="prime-powers">Prime Powers (p^k, k>=1)</option>
                    <option value="perfect-squares">Perfect Squares</option>
                    <option value="square-free">Square-free Numbers</option>
                    <option value="perfect">Perfect Numbers</option>
                    <option value="abundant">Abundant Numbers</option>
                    <option value="deficient">Deficient Numbers</option>
                </select>
            </div>
            <div class="control-group">
                <label for="color-mode">Point Color Mode:</label>
                <select id="color-mode">
                    <option value="default">Default by View</option>
                    <option value="lambda">By Liouville Function λ(n)</option>
                </select>
            </div>
        </div>

        <div class="visualization-grid">
            <div class="view-container">
                <div class="view-header isg">
                    <div class="view-info isg">
                        <h3>ISG (Peak Usage vs. Size)</h3>
                        <p><span class="axis-desc">X: Peak Usage</span> (Max Exponent)</p>
                        <p><span class="axis-desc">Y: Structural Size</span> (Total Factors Ω(n))</p>
                    </div>
                    <div class="view-controls">
                        <label for="isg-x-scale">X:</label><select id="isg-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                        <label for="isg-y-scale">Y:</label><select id="isg-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                    </div>
                </div>
                <div id="isg-stats" class="stats-display">Statistics loading...</div>
                <div id="isg-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
            </div>
            <div class="view-container">
                <div class="view-header dfg">
                    <div class="view-info dfg">
                        <h3>DFG (Variety vs. Peak Usage)</h3>
                        <p><span class="axis-desc">X: Variety</span> (Distinct Factors ω(n))</p>
                        <p><span class="axis-desc">Y: Peak Usage</span> (Max Exponent)</p>
                    </div>
                    <div class="view-controls">
                        <label for="dfg-x-scale">X:</label><select id="dfg-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                        <label for="dfg-y-scale">Y:</label><select id="dfg-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                    </div>
                </div>
                <div id="dfg-stats" class="stats-display">Statistics loading...</div>
                <div id="dfg-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
            </div>
            <div class="view-container">
                <div class="view-header omegaomega">
                    <div class="view-info omegaomega">
                        <h3>OO (Variety vs. Size)</h3>
                        <p><span class="axis-desc">X: Variety</span> (Distinct Factors ω(n))</p>
                        <p><span class="axis-desc">Y: Structural Size</span> (Total Factors Ω(n))</p>
                    </div>
                    <div class="view-controls">
                        <label for="omegaomega-x-scale">X:</label><select id="omegaomega-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                        <label for="omegaomega-y-scale">Y:</label><select id="omegaomega-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select>
                    </div>
                </div>
                <div id="omegaomega-stats" class="stats-display">Statistics loading...</div>
                <div id="omegaomega-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
            </div>
            <div class="view-container">
                <div class="view-header combined">
                    <div class="view-info combined">
                        <h3>Combined 3D</h3>
                        <p><span class="axis-desc">X: Variety</span> (ω(n))</p>
                        <p><span class="axis-desc">Y: Peak Usage</span> (Max Exp)</p>
                        <p><span class="axis-desc">Z: Structural Size</span> (Ω(n))</p>
                    </div>
                </div>
                <div id="combined-stats" class="stats-display">(3D View)</div>
                <div id="combined-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
            </div>
        </div>

        <section class="insights-section">
            <h2>Mathematical Insights & Interpretations</h2>
            <details>
                <summary>Transformational: Exponentiation & Scaling Rays</summary>
                <div class="insight-content">
                    <span class="view-ref">Most apparent in: ISG View (Peak Usage vs. Size)</span>
                    <h4>Property:</h4> <p>If <code>m</code> maps to <code>(Peak_m, Size_m)</code>, then <code>m^k</code> maps to <code>(k * Peak_m, k * Size_m)</code>.</p>
                    <h4>Result:</h4> <p>Powers <code>m, m², m³, ...</code> form straight rays from (0,0) on the ISG plot.</p>
                    <h4>Interpretation:</h4> <p class="emphasis">The arithmetic act of exponentiation (intensifying the 'Pattern of Relatedness') corresponds directly to geometric scaling in this view. The rays visualize this <strong class="concept-highlight">transformational meta-relationship</strong>.</p>
                </div>
            </details>
            <details>
                <summary>Affinity: Liouville Function λ(n) & Parity</summary>
                <div class="insight-content">
                    <span class="view-ref">Apparent in: ISG, OO Views (Y-axis = Size Ω(n)); Explicit in Lambda Color Mode</span>
                    <h4>Property:</h4> <p><code>λ(n) = (-1)^Ω(n)</code>. The Y-coordinate in ISG/OO is <code>y = Ω(n)</code>.</p>
                    <h4>Result:</h4> <p>All integers on the same horizontal line <code>y = k</code> in ISG/OO share the same <code>λ(n) = (-1)^k</code> value (same parity of total factors). Lambda color mode directly shows this grouping.</p>
                    <h4>Interpretation:</h4> <p class="emphasis">The grid structure inherently groups Patterns by the parity of their total 'Structural Size' (Ω). This reveals an <strong class="concept-highlight">affinity meta-relationship</strong> between the grid layout and this fundamental number property.</p>
                </div>
            </details>
            <details>
                <summary>Combinatorial: Multiplication Rules</summary>
                <div class="insight-content">
                    <span class="view-ref">Relevant to all views, effects vary.</span>
                    <h4>Property:</h4> <p>If <code>n = a * b</code>:</p>
                    <ul>
                        <li>'Structural Size' (Ω): Always additive: <code>Ω(n) = Ω(a) + Ω(b)</code>.</li>
                        <li>'Variety' (ω): Additive only if <code>a, b</code> are coprime.</li>
                        <li>'Peak Usage' (Max Exp): Complex interaction; <code>max_exp(n) = max_p{v_p(a) + v_p(b)}</code>, which simplifies to <code>max(max_exp(a), max_exp(b))</code> only if <code>a, b</code> are coprime.</li>
                    </ul>
                    <h4>Interpretation:</h4> <p class="emphasis">These rules show the <strong class="concept-highlight">combinatorial meta-relationships</strong>. 'Structural Size' (Ω) combines simply, while 'Variety' (ω) and 'Peak Usage' (Max Exp) interact more complexly, revealing how "Patterns of Relatedness" combine under multiplication.</p>
                </div>
            </details>
            <details>
                <summary>Relational Shape: Structural Spread & Contours</summary>
                <div class="insight-content">
                    <span class="view-ref">Apparent in: ISG View, OmegaOmega View</span>
                    <h4>Property:</h4>
                    <ul>
                        <li>ISG Spread: <code>d₁ = Ω(n) - max{eᵢ}</code> ('Size' - 'Peak Usage'). <code>d₁=0</code> for prime powers (<code>y=x</code> line).</li>
                        <li>OO Spread (Repetition): <code>d₂ = Ω(n) - ω(n)</code> ('Size' - 'Variety'). <code>d₂=0</code> for square-free (<code>y=x</code> line).</li>
                    </ul>
                    <h4>Result:</h4> <p>Lines where <code>d₁</code> (ISG) or <code>d₂</code> (OO) are constant run parallel to the <code>y=x</code> diagonal in those plots.</p>
                    <h4>Interpretation:</h4> <p class="emphasis">These differences quantify the <strong class="concept-highlight">relational shape meta-relationship</strong>, measuring the internal balance or spread of the Pattern. Contours group structures with similar shapes (peaked vs. spread in ISG; repetitive vs. non-repetitive in OO).</p>
                </div>
            </details>
            <details>
                <summary>Statistical: Density, Distribution & ζ(s)</summary>
                <div class="insight-content">
                    <span class="view-ref">Apparent in: DFG View (Variety vs. Peak Usage)</span>
                    <h4>Property & Result:</h4>
                    <ul>
                        <li>Numbers with 'Peak Usage' <code>max{eᵢ} <= m</code> are (m+1)-free.</li>
                        <li>In DFG, these correspond to the region <code>Y <= m</code>.</li>
                        <li>Asymptotic density of (m+1)-free numbers is <code>1/ζ(m+1)</code>.</li>
                        <li>Specifically, Square-Free (<code>Y=1</code> region) density ≈ <code>1/ζ(2)</code>. Cube-Free (<code>Y<=2</code> region) density ≈ <code>1/ζ(3)</code>.</li>
                    </ul>
                    <p>The DFG statistics compare actual vs. theoretical densities.</p>
                    <h4>Interpretation:</h4> <p class="emphasis">Reveals a <strong class="concept-highlight">statistical meta-relationship</strong>. The DFG layout directly reflects fundamental constants (ζ values) governing the global distribution of integers based on their 'Peak Usage' limits (power-freeness). The distribution along the X-axis ('Variety' ω) also connects to the Erdős–Kac theorem's `log(log N)` behavior.</p>
                </div>
            </details>
        </section>

        <div class="factor-panel">
            <h2>Integer Analysis</h2>
            <div id="factor-details" class="factor-details">
                <div class="factor-group"><h3>Information Panel</h3><p>Click a point or enter an integer above.</p></div>
            </div>
        </div>
    </div>

    <script>
        // ----- CONSTANTS -----
        const MAX_RANGE_LIMIT = 5000;

        // ----- APPLICATION STATE -----
        let appData = {
            integers: [],
            processedData: [],
            coordDensity: {},
            markerSizes: {},
            markerOpacities: {},
            currentColors: {}
        };

        // ----- MODULE: NumberTheoryUtils -----
        const NumberTheoryUtils = {
            factorizationCache: new Map(),
            propertiesCache: new Map(),

            getPrimeFactorization: function(n) {
                if (n <= 0 || !Number.isInteger(n)) { throw new Error("Input must be a positive integer."); }
                if (this.factorizationCache.has(n)) { return this.factorizationCache.get(n); }
                if (n === 1) { this.factorizationCache.set(1, {}); return {}; }

                const factors = {};
                let num = n;
                while (num % 2 === 0) { factors[2] = (factors[2] || 0) + 1; num /= 2; }
                for (let i = 3; i * i <= num; i += 2) {
                    while (num % i === 0) { factors[i] = (factors[i] || 0) + 1; num /= i; }
                }
                if (num > 1) { factors[num] = (factors[num] || 0) + 1; }
                this.factorizationCache.set(n, factors);
                return factors;
            },

            calculateProperties: function(n) {
                if (this.propertiesCache.has(n)) { return this.propertiesCache.get(n); }
                if (n === 1) {
                    const props = { n: 1, factorization: {}, isg: [0, 0], dfg: [0, 0], omegaomega: [0, 0], omega: 0, Omega: 0, maxExp: 0, lambda: 1, sigma: 1, d: 1, isPrime: false, isPrimePower: false, isSquareFree: true, isPerfectSquare: true, isPerfect: false, isAbundant: false, isDeficient: false };
                    this.propertiesCache.set(1, props);
                    return props;
                }

                const factorization = this.getPrimeFactorization(n);
                const exponents = Object.values(factorization);
                const primes = Object.keys(factorization).map(Number);
                const distinctFactors = primes.length;
                const maxExponent = exponents.length > 0 ? Math.max(...exponents) : 0;
                const totalFactors = exponents.reduce((s, e) => s + e, 0);

                let numDivisors = 1;
                let sumDivisors = 1;
                for (let i = 0; i < primes.length; i++) {
                    const p = primes[i];
                    const e = exponents[i];
                    numDivisors *= (e + 1);
                    sumDivisors *= (Math.pow(p, e + 1) - 1) / (p - 1);
                }

                const lambda = (totalFactors % 2 === 0) ? 1 : -1;
                const isPrime = distinctFactors === 1 && maxExponent === 1;
                const isPrimePower = distinctFactors === 1 && totalFactors >= 1;
                const isSquareFree = maxExponent <= 1;
                const isPerfectSquare = exponents.every(e => e % 2 === 0);

                const sigma_minus_2n = sumDivisors - 2 * n;
                const isPerfect = sigma_minus_2n === 0;
                const isAbundant = sigma_minus_2n > 0;
                const isDeficient = sigma_minus_2n < 0;

                const props = {
                    n, factorization,
                    isg: [maxExponent, totalFactors],
                    dfg: [distinctFactors, maxExponent],
                    omegaomega: [distinctFactors, totalFactors],
                    omega: distinctFactors, Omega: totalFactors, maxExp: maxExponent,
                    lambda, sigma: sumDivisors, d: numDivisors,
                    isPrime, isPrimePower, isSquareFree, isPerfectSquare,
                    isPerfect, isAbundant, isDeficient
                };
                this.propertiesCache.set(n, props);
                return props;
            },

            generateIntegerRange: function(input) {
                input = input.trim();
                if (!input) throw new Error("Input cannot be empty.");

                if (input.includes('-')) {
                    const parts = input.split('-');
                    if (parts.length !== 2) throw new Error("Invalid range format (e.g., 1-100).");
                    const start = parseInt(parts[0].trim());
                    const end = parseInt(parts[1].trim());
                    if (isNaN(start) || isNaN(end) || start < 1 || end < start) {
                        throw new Error("Invalid range values (start >= 1, end >= start).");
                    }
                    if (end - start + 1 > MAX_RANGE_LIMIT) {
                        throw new Error(`Range too large (max ${MAX_RANGE_LIMIT} numbers). Current: ${end - start + 1}.`);
                    }
                    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
                } else {
                    const n = parseInt(input);
                    if (isNaN(n) || n < 1) {
                        throw new Error("Invalid integer (must be >= 1).");
                    }
                    // Soft warning for single very large numbers can be added here if needed
                    return [n];
                }
            },

            clearCaches: function() {
                this.factorizationCache.clear();
                this.propertiesCache.clear();
            }
        };

        // ----- MODULE: UIUpdater -----
        const UIUpdater = {
            formatFactorizationHTML: function(factorization) {
                if (Object.keys(factorization).length === 0) return "1";
                return Object.entries(factorization)
                    .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
                    .map(([p, e]) => e === 1 ? p : `${p}<span class="sup">${e}</span>`)
                    .join(" × ");
            },

            updateFactorInfo: function(n) {
                const factorDetails = document.getElementById("factor-details");
                try {
                    if (isNaN(n) || n < 1) {
                        factorDetails.innerHTML = `<div class="factor-group"><h3>Info Panel</h3><p>Enter a valid positive integer or click a point on the plots.</p></div>`;
                        return;
                    }
                    let props = NumberTheoryUtils.propertiesCache.get(n);
                    if (!props) {
                        try {
                            props = NumberTheoryUtils.calculateProperties(n); // Calculate if not in cache
                        } catch (calcError) {
                            factorDetails.innerHTML = `<div class="factor-group"><h3>Integer: ${n}</h3><p>Data not calculated for this specific number. Visualize the range containing this number or check input.</p></div>`;
                            return;
                        }
                    }
                    this._displayFactorDetails(props, factorDetails);

                } catch (error) {
                    console.error("Error updating factor info:", error);
                    factorDetails.innerHTML = `<div class="factor-group"><h3>Error</h3><p>Could not display info for ${n}. ${error.message}</p></div>`;
                }
            },

            _displayFactorDetails: function(props, element) {
                let specialPropsText = [];
                if (props.isPrime) specialPropsText.push("Prime");
                else if (props.isPrimePower && props.n > 1) specialPropsText.push("Prime Power");

                if (props.isPerfectSquare && props.n > 1) specialPropsText.push("Perfect Square");

                if (props.isSquareFree && !props.isPrime && props.n > 1) specialPropsText.push("Square-free Composite");
                else if (props.isSquareFree && props.n === 1) specialPropsText.push("Square-free");

                let divisorPropsText = "";
                if (props.isPerfect && props.n > 1) divisorPropsText = "Perfect";
                else if (props.isAbundant) divisorPropsText = "Abundant";
                else if (props.isDeficient || props.n === 1) divisorPropsText = "Deficient";
                if (divisorPropsText) specialPropsText.push(divisorPropsText + ` (σ(n)=${props.sigma})`);

                element.innerHTML = `
                    <div class="factor-group">
                        <h3>Integer: ${props.n}</h3>
                        <p><strong>Factorization:</strong> ${this.formatFactorizationHTML(props.factorization)}</p>
                        <p><strong>Properties:</strong> ${specialPropsText.length ? specialPropsText.join(", ") : (props.n === 1 ? "Unit" : "Composite")}</p>
                    </div>
                    <div class="factor-group">
                        <h3>Coordinates</h3>
                        <p><strong>ISG (MaxExp, Ω):</strong> (${props.isg.join(", ")})</p>
                        <p><strong>DFG (ω, MaxExp):</strong> (${props.dfg.join(", ")})</p>
                        <p><strong>OO (ω, Ω):</strong> (${props.omegaomega.join(", ")})</p>
                    </div>
                    <div class="factor-group">
                        <h3>Metrics</h3>
                        <p><strong>ω(n) (Distinct):</strong> ${props.omega}</p>
                        <p><strong>Ω(n) (Total):</strong> ${props.Omega}</p>
                        <p><strong>Max Exponent:</strong> ${props.maxExp}</p>
                        <p><strong>λ(n) (Liouville):</strong> ${props.lambda}</p>
                        <p><strong>d(n) (Divisors):</strong> ${props.d}</p>
                        <p><strong>σ(n) (Sum Divisors):</strong> ${props.sigma}</p>
                    </div>`;
            },

            clearFactorInfo: function() {
                document.getElementById("factor-details").innerHTML = `<div class="factor-group"><h3>Information Panel</h3><p>Click a point or enter an integer above.</p></div>`;
            }
        };

        // ----- MODULE: StatsModule -----
        const StatsModule = {
            ZETA_VALUES: { 2: 1.644934, 3: 1.202057, 4: 1.082323, 5: 1.036928 },

            calculateAndDisplayStats: function(processedData, N_max_in_range) {
                const statsElements = {
                    isg: document.getElementById('isg-stats'),
                    dfg: document.getElementById('dfg-stats'),
                    omegaomega: document.getElementById('omegaomega-stats'),
                    combined: document.getElementById('combined-stats')
                };

                if (!processedData || processedData.length === 0) {
                    Object.values(statsElements).forEach(el => el.textContent = (el.id === 'combined-stats' ? "(3D View)" : "No data."));
                    return;
                }

                const count = processedData.length;
                const omegaValues = processedData.map(d => d.omega);
                const actualSqFree = processedData.filter(d => d.isSquareFree).length;
                const actualCubeFree = processedData.filter(d => d.maxExp <= 2).length;

                const densitySqFree = (actualSqFree / count * 100).toFixed(1);
                const densityCubeFree = (actualCubeFree / count * 100).toFixed(1);
                const theoreticalSqFree = (1 / this.ZETA_VALUES[2] * 100).toFixed(1);
                const theoreticalCubeFree = (1 / this.ZETA_VALUES[3] * 100).toFixed(1);

                const meanOmega = omegaValues.reduce((s, v) => s + v, 0) / count;
                const stdDevOmega = Math.sqrt(omegaValues.reduce((s, v) => s + (v - meanOmega)**2, 0) / count);
                const theoreticalMeanOmega = N_max_in_range > 2 ? Math.log(Math.log(N_max_in_range)) : 0;

                statsElements.dfg.innerHTML = `
                    <p title="Density of numbers n where max exponent in factorization is <= 1. Theoretical ≈ 1/ζ(2)">Sq-Free (Act: ${densitySqFree}%, Th: ${theoreticalSqFree}%) | <span title="Density where max exponent <= 2. Theoretical ≈ 1/ζ(3)">Cube-Free (Act: ${densityCubeFree}%, Th: ${theoreticalCubeFree}%)</span></p>
                    <p title="Average number of distinct prime factors ω(n). Theoretical ≈ log(log(N)) by Erdős–Kac.">ω(n) Avg (Act: ${meanOmega.toFixed(2)}, Th: ${theoreticalMeanOmega.toFixed(2)}) | StdDev (Act: ${stdDevOmega.toFixed(2)}, Th: ${theoreticalMeanOmega > 0 ? Math.sqrt(theoreticalMeanOmega).toFixed(2) : 'N/A'})</p>`;

                statsElements.isg.innerHTML = `<p>Total Points: ${count}. Avg Ω(n): ${(processedData.reduce((s, d) => s + d.Omega, 0) / count).toFixed(2)}.</p>`;
                statsElements.omegaomega.innerHTML = `<p>ω(n) Avg (Act: ${meanOmega.toFixed(2)}, Th: ${theoreticalMeanOmega.toFixed(2)}) | StdDev (Act: ${stdDevOmega.toFixed(2)}, Th: ${theoreticalMeanOmega > 0 ? Math.sqrt(theoreticalMeanOmega).toFixed(2) : 'N/A'})</p>`;
                statsElements.combined.textContent = `(3D View - ${count} points)`;
            }
        };

        // ----- MODULE: PlotManager -----
        const PlotManager = {
            viewConfigs: {
                isg: { type: 'scatter', x: 'isg[0]', y: 'isg[1]', xLabel: 'Max Exp', yLabel: 'Total Ω(n)', color: 'var(--primary-color)', containerId: 'isg-visualization', statsId: 'isg-stats' },
                dfg: { type: 'scatter', x: 'dfg[0]', y: 'dfg[1]', xLabel: 'Distinct ω(n)', yLabel: 'Max Exp', color: 'var(--secondary-color)', containerId: 'dfg-visualization', statsId: 'dfg-stats' },
                omegaomega: { type: 'scatter', x: 'omegaomega[0]', y: 'omegaomega[1]', xLabel: 'Distinct ω(n)', yLabel: 'Total Ω(n)', color: 'var(--tertiary-color)', containerId: 'omegaomega-visualization', statsId: 'omegaomega-stats' },
                combined: { type: 'scatter3d', x: 'omega', y: 'maxExp', z: 'Omega', xLabel: 'Distinct ω(n)', yLabel: 'Max Exp', zLabel: 'Total Ω(n)', color: 'var(--quaternary-color)', containerId: 'combined-visualization', statsId: 'combined-stats' }
            },

            getNestedValue: function(obj, path) {
                if (!path) return undefined;
                const keys = path.replace(/\[(\d+)\]/g, '.$1').split('.');
                let v = obj;
                for (const k of keys) {
                    if (v === undefined || v === null) return undefined;
                    v = v[k];
                }
                return v;
            },

            getPlotAnnotationsAndShapes: function(view, processedData) {
                const shapes = [];
                const annotations = [];
                if (!processedData || processedData.length === 0) return { shapes, annotations };

                const xData = processedData.map(d => this.getNestedValue(d, this.viewConfigs[view].x));
                const yData = processedData.map(d => this.getNestedValue(d, this.viewConfigs[view].y));
                const maxX = Math.max(...xData, 0);
                const maxY = Math.max(...yData, 0);
                const maxDim = Math.max(maxX, maxY, 1);

                const lineStyle = { type: 'line', line: { color: 'rgba(0,0,0,0.3)', width: 1, dash: 'dot' }, layer: 'below' };
                const annoStyle = { showarrow: false, font: { size: 10, color: 'grey'}, bgcolor: 'rgba(255,255,255,0.6)', xanchor: 'left', yanchor: 'bottom' };

                switch (view) {
                    case 'isg':
                        shapes.push({ ...lineStyle, x0: 0, y0: 0, x1: maxDim, y1: maxDim });
                        annotations.push({ ...annoStyle, x: maxDim * 0.95, y: maxDim * 0.95, text: 'y=x (p^k)'});
                        break;
                    case 'dfg':
                        shapes.push({ ...lineStyle, type: 'line', x0: 1, y0: 0, x1: 1, y1: maxY + 0.5 });
                        annotations.push({ ...annoStyle, x: 1.05, y: maxY * 0.95, text: 'ω=1 (p^k)'});
                        shapes.push({ type: 'rect', x0: 0.5, y0: 0.5, x1: maxX + 0.5, y1: 1.5, fillcolor: 'rgba(0,100,0,0.03)', layer: 'below', line: {width: 0} });
                        annotations.push({ ...annoStyle, x: 0.6, y: 0.6, text: 'Sq-Free (Y=1)', xanchor:'left', yanchor:'bottom'});
                        break;
                    case 'omegaomega':
                        shapes.push({ ...lineStyle, x0: 1, y0: 1, x1: maxDim, y1: maxDim });
                        annotations.push({ ...annoStyle, x: maxDim * 0.95, y: maxDim * 0.95, text: 'y=x (Sq-Free)'});
                        break;
                }
                return { shapes, annotations };
            },

            createOrUpdateVisualization: function(view, processedData) {
                const config = this.viewConfigs[view];
                const plotDiv = document.getElementById(config.containerId);
                const loader = plotDiv.querySelector('.loader');
                loader.style.display = 'block';

                const xData = processedData.map(d => this.getNestedValue(d, config.x));
                const yData = processedData.map(d => this.getNestedValue(d, config.y));
                const zData = config.z ? processedData.map(d => this.getNestedValue(d, config.z)) : undefined;

                const colorMode = document.getElementById('color-mode').value;
                let baseMarkerColors;
                if (colorMode === 'lambda') {
                    baseMarkerColors = processedData.map(d => d.lambda === 1 ? 'var(--lambda-pos-color)' : 'var(--lambda-neg-color)');
                } else {
                    baseMarkerColors = new Array(processedData.length).fill(config.color);
                }
                appData.currentColors[view] = baseMarkerColors;

                const trace = {
                    x: xData, y: yData, mode: 'markers', type: config.type,
                    text: processedData.map(d => {
                        let coordsText = config.z ? `${this.getNestedValue(d, config.x)},${this.getNestedValue(d, config.y)},${this.getNestedValue(d, config.z)}`
                                              : `${this.getNestedValue(d, config.x)},${this.getNestedValue(d, config.y)}`;
                        return `n=${d.n}<br>Coords:(${coordsText})<br>λ(n):${d.lambda}`;
                    }),
                    hoverinfo: 'text',
                    marker: {
                        size: appData.markerSizes[view],
                        color: baseMarkerColors,
                        opacity: appData.markerOpacities[view],
                        line: { color: 'rgba(0,0,0,0.3)', width: 0.5 }
                    },
                    customdata: processedData.map(d => d.n)
                };
                if (config.type === 'scatter3d') { trace.z = zData; }

                const xScaleType = document.getElementById(`${view}-x-scale`)?.value || 'linear';
                const yScaleType = document.getElementById(`${view}-y-scale`)?.value || 'linear';

                const layout = {
                    hovermode: 'closest', margin: { l: 60, r: 30, b: 60, t: 80 },
                    autosize: true, paper_bgcolor: 'white', plot_bgcolor: 'white'
                };

                if (config.type === 'scatter3d') {
                    layout.scene = {
                        xaxis:{title:config.xLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'},
                        yaxis:{title:config.yLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'},
                        zaxis:{title:config.zLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'},
                        aspectratio:{x:1,y:1,z:0.8}
                    };
                    layout.margin = {l:10,r:10,b:10,t:50};
                } else {
                    layout.xaxis = {title:config.xLabel, type:xScaleType, zeroline:false, gridcolor:'#eee', rangemode:'tozero'};
                    layout.yaxis = {title:config.yLabel, type:yScaleType, zeroline:false, gridcolor:'#eee', rangemode:'tozero'};
                    const { shapes, annotations } = this.getPlotAnnotationsAndShapes(view, processedData);
                    layout.shapes = shapes;
                    layout.annotations = annotations;
                }

                Plotly.react(plotDiv, [trace], layout, {responsive: true}).then(() => {
                    loader.style.display = 'none';
                    const plotElement = document.getElementById(config.containerId);
                    if (plotElement && plotElement.on) {
                        plotElement.removeAllListeners('plotly_click');
                        plotElement.on('plotly_click', function(data) {
                            if (data.points.length > 0) {
                                const clickedN = data.points[0].customdata;
                                document.getElementById('highlight-input').value = clickedN;
                                UIUpdater.updateFactorInfo(clickedN);
                                PlotManager.highlightInteger(clickedN);
                            }
                        });
                    }
                }).catch(err => {
                    console.error(`Plotly error for view ${view}:`, err);
                    loader.textContent = 'Error rendering plot.';
                });
            },

            highlightInteger: function(n_to_highlight) {
                const n = (isNaN(n_to_highlight) || n_to_highlight < 1) ? -1 : n_to_highlight;

                const hlMkr = { color: '#FF0000', sizeFactor: 1.5, line: { color: '#000000', width: 2 }, opacity: 1 };
                const hlMkr3D = { color: '#FF0000', sizeFactor: 1.5, opacity: 1 };

                Object.entries(this.viewConfigs).forEach(([view, config]) => {
                    const plotDiv = document.getElementById(config.containerId);
                    if (!(plotDiv && plotDiv.data && plotDiv.data.length > 0 && appData.markerSizes[view])) return;

                    const traceIndex = 0;
                    const trace = plotDiv.data[traceIndex];
                    if (!trace || !trace.customdata) return;

                    const baseSizes = appData.markerSizes[view];
                    const baseOpacities = appData.markerOpacities[view];
                    const baseColors = appData.currentColors?.[view] ? [...appData.currentColors[view]] : new Array(trace.customdata.length).fill(config.color);

                    const markerColors = [...baseColors];
                    const sizes = [...baseSizes];
                    const opacities = [...baseOpacities];
                    const lineColors = new Array(trace.customdata.length).fill('rgba(0,0,0,0.3)');
                    const lineWidths = new Array(trace.customdata.length).fill(0.5);

                    let needsRestyle = false;
                    if (n !== -1) {
                        trace.customdata.forEach((val, index) => {
                            if (val === n) {
                                needsRestyle = true;
                                const currentHl = config.type === 'scatter3d' ? hlMkr3D : hlMkr;
                                markerColors[index] = currentHl.color;
                                sizes[index] = baseSizes[index] * currentHl.sizeFactor;
                                opacities[index] = currentHl.opacity;
                                if (currentHl.line) {
                                    lineColors[index] = currentHl.line.color;
                                    lineWidths[index] = currentHl.line.width;
                                }
                            }
                        });
                    } else {
                        needsRestyle = true; // Force restyle to revert all points
                    }

                    if (needsRestyle) {
                        Plotly.restyle(plotDiv, {
                            'marker.color': [markerColors],
                            'marker.size': [sizes],
                            'marker.opacity': [opacities],
                            'marker.line.color': [lineColors],
                            'marker.line.width': [lineWidths]
                        }, traceIndex);
                    }
                });
            },

            highlightCategory: function(category) {
                if (!appData.processedData || appData.processedData.length === 0) return;

                const highlightOpacity = 0.95;
                const dimOpacity = 0.15;
                let filterFn;
                switch(category) {
                    case "primes": filterFn = d => d.isPrime; break;
                    case "prime-powers": filterFn = d => d.isPrimePower; break;
                    case "perfect-squares": filterFn = d => d.isPerfectSquare; break;
                    case "square-free": filterFn = d => d.isSquareFree; break;
                    case "perfect": filterFn = d => d.isPerfect; break;
                    case "abundant": filterFn = d => d.isAbundant; break;
                    case "deficient": filterFn = d => d.isDeficient; break;
                    default: filterFn = d => true;
                }

                const highlightIndices = new Set(
                    appData.processedData.map((d, i) => filterFn(d) ? i : -1).filter(i => i !== -1)
                );

                Object.entries(this.viewConfigs).forEach(([view, config]) => {
                    const plotDiv = document.getElementById(config.containerId);
                    if (!(plotDiv && plotDiv.data && plotDiv.data.length > 0 && appData.markerOpacities[view])) return;

                    const traceIndex = 0;
                    const numPoints = plotDiv.data[traceIndex].customdata.length;
                    const baseOpacities = appData.markerOpacities[view];
                    let opacities = new Array(numPoints);

                    if (category === 'none') {
                        opacities = [...baseOpacities];
                        this.highlightInteger(-1); // Clear specific integer highlight
                    } else {
                        for(let i=0; i < numPoints; i++) {
                            opacities[i] = highlightIndices.has(i) ? highlightOpacity : dimOpacity;
                        }
                    }
                    Plotly.restyle(plotDiv, { 'marker.opacity': [opacities] }, traceIndex);
                });
            },

            purgeAllPlots: function() {
                Object.values(this.viewConfigs).forEach(config => {
                    const plotDiv = document.getElementById(config.containerId);
                    const loader = plotDiv.querySelector('.loader');
                    loader.style.display = 'block';
                    loader.textContent = 'Initializing...';
                    Plotly.purge(plotDiv);
                    document.getElementById(config.statsId).innerHTML = "Calculating...";
                });
            },

            hideAllLoaders: function() {
                Object.values(this.viewConfigs).forEach(config => {
                    const plotDiv = document.getElementById(config.containerId);
                    const loader = plotDiv?.querySelector('.loader');
                    if (loader) loader.style.display = 'none';
                });
            }
        };

        // ----- MAIN APPLICATION LOGIC & ORCHESTRATION -----
        function initializeUIForProcessing() {
            const visualizeBtn = document.getElementById('visualize-btn');
            visualizeBtn.disabled = true;
            visualizeBtn.textContent = 'Processing...';
            document.getElementById('range-error-message').textContent = '';
            NumberTheoryUtils.clearCaches();
            PlotManager.purgeAllPlots();
        }

        function finalizeUI(errorOccurred = false) {
            const visualizeBtn = document.getElementById('visualize-btn');
            visualizeBtn.disabled = false;
            visualizeBtn.textContent = 'Visualize';
            if (errorOccurred) {
                PlotManager.hideAllLoaders();
            }
        }

        function fetchAndProcessInputData() {
            const input = document.getElementById("integer-input").value;
            const integers = NumberTheoryUtils.generateIntegerRange(input);
            const maxN = integers.length > 0 ? integers[integers.length - 1] : 0;

            appData.integers = integers;
            appData.processedData = integers.map(n => NumberTheoryUtils.calculateProperties(n));

            const colorMode = document.getElementById('color-mode').value;
            Object.keys(PlotManager.viewConfigs).forEach(view => {
                const config = PlotManager.viewConfigs[view];
                appData.coordDensity[view] = {};

                appData.processedData.forEach(d => {
                    const ck = config.z ? `${PlotManager.getNestedValue(d, config.x)},${PlotManager.getNestedValue(d, config.y)},${PlotManager.getNestedValue(d, config.z)}`
                                        : `${PlotManager.getNestedValue(d, config.x)},${PlotManager.getNestedValue(d, config.y)}`;
                    appData.coordDensity[view][ck] = (appData.coordDensity[view][ck] || 0) + 1;
                });

                appData.markerSizes[view] = appData.processedData.map(d => {
                    const ck = config.z ? `${PlotManager.getNestedValue(d, config.x)},${PlotManager.getNestedValue(d, config.y)},${PlotManager.getNestedValue(d, config.z)}`
                                        : `${PlotManager.getNestedValue(d, config.x)},${PlotManager.getNestedValue(d, config.y)}`;
                    const cnt = appData.coordDensity[view][ck] || 1;
                    const baseSize = config.type === 'scatter3d' ? 3 : 5;
                    const maxSize = config.type === 'scatter3d' ? 10 : 15;
                    return Math.min(maxSize, baseSize + Math.sqrt(cnt));
                });
                appData.markerOpacities[view] = new Array(appData.processedData.length).fill(0.7);

                if (colorMode === 'lambda') {
                    appData.currentColors[view] = appData.processedData.map(d => d.lambda === 1 ? 'var(--lambda-pos-color)' : 'var(--lambda-neg-color)');
                } else {
                    appData.currentColors[view] = new Array(appData.processedData.length).fill(config.color);
                }
            });
            return { processedData: appData.processedData, maxN };
        }

        function updateAllVisualizations(processedData, maxN) {
            StatsModule.calculateAndDisplayStats(processedData, maxN);
            Object.keys(PlotManager.viewConfigs).forEach(view => {
                PlotManager.createOrUpdateVisualization(view, processedData);
            });
        }

        function applyCurrentHighlightsAndInfo() {
            const category = document.getElementById("special-category").value;
            PlotManager.highlightCategory(category);

            const highlightNInput = document.getElementById("highlight-input").value;
            if (highlightNInput) {
                const highlightN = parseInt(highlightNInput);
                if (!isNaN(highlightN) && highlightN >= 1) {
                    UIUpdater.updateFactorInfo(highlightN);
                    PlotManager.highlightInteger(highlightN);
                } else {
                    UIUpdater.updateFactorInfo(NaN);
                    PlotManager.highlightInteger(-1);
                }
            } else {
                UIUpdater.updateFactorInfo(NaN);
                PlotManager.highlightInteger(-1);
            }
        }

        async function processAndVisualize() {
            initializeUIForProcessing();
            let errorOccurred = false;
            try {
                await new Promise(resolve => setTimeout(resolve, 10)); // UI update tick

                const { processedData, maxN } = fetchAndProcessInputData();
                updateAllVisualizations(processedData, maxN);
                applyCurrentHighlightsAndInfo();

            } catch (error) {
                errorOccurred = true;
                const rangeErrorEl = document.getElementById('range-error-message');
                const knownErrorMessages = ["Range too large", "Invalid range", "Invalid integer", "Input cannot be empty"];
                if (rangeErrorEl && knownErrorMessages.some(msg => error.message.includes(msg))) {
                    rangeErrorEl.textContent = error.message;
                } else {
                    rangeErrorEl.textContent = "An unexpected error occurred. Check console.";
                    console.error("Processing Error:", error);
                }
            } finally {
                finalizeUI(errorOccurred);
            }
        }

        // ----- EVENT LISTENERS INITIALIZATION -----
        function initializeEventListeners() {
            document.getElementById("visualize-btn").addEventListener("click", processAndVisualize);

            document.getElementById("integer-input").addEventListener("input", function() {
                document.getElementById('range-error-message').textContent = '';
            });

            document.getElementById("highlight-input").addEventListener("input", function() {
                const nVal = this.value;
                if (!nVal) {
                    UIUpdater.updateFactorInfo(NaN);
                    PlotManager.highlightInteger(-1);
                    return;
                }
                const n = parseInt(nVal);
                if (!isNaN(n) && n >= 1) {
                    UIUpdater.updateFactorInfo(n);
                    PlotManager.highlightInteger(n);
                } else if (nVal) {
                    UIUpdater.updateFactorInfo(NaN);
                    PlotManager.highlightInteger(-1);
                }
            });

            document.getElementById("special-category").addEventListener("change", function() {
                PlotManager.highlightCategory(this.value);
                const highlightN = parseInt(document.getElementById("highlight-input").value);
                if (!isNaN(highlightN) && highlightN >= 1) {
                    PlotManager.highlightInteger(highlightN);
                }
            });

            document.getElementById("color-mode").addEventListener("change", processAndVisualize);
            document.querySelectorAll(".axis-scale").forEach(sel => sel.addEventListener("change", processAndVisualize));
        }

        // ----- DOMContentLoaded -----
        document.addEventListener("DOMContentLoaded", () => {
            initializeEventListeners();
            processAndVisualize(); // Initial visualization
        });
    </script>
</body>
</html>
