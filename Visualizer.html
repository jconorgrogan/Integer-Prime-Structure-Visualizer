<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integer Prime Structure Visualizer - Enhanced with Insights</title>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        /* --- Root Variables --- */
        :root {
            --primary-color: #4285F4;    /* ISG / Blue */
            --secondary-color: #34A853;  /* DFG / Green */
            --tertiary-color: #FBBC05;   /* OmegaOmega / Yellow */
            --quaternary-color: #EA4335; /* Combined / Red */
            --lambda-pos-color: #1a73e8; /* Color for lambda = +1 */
            --lambda-neg-color: #d93025; /* Color for lambda = -1 */
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --light-text: #fff;
            --border-color: #dee2e6;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --border-radius: 8px;
        }

        /* --- Basic Reset & Body --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--dark-text);
            background-color: var(--light-bg);
            padding: 20px;
        }

        /* --- Main Container & Header --- */
        .container { max-width: 1700px; margin: 0 auto; background-color: white; border-radius: var(--border-radius); padding: 30px; box-shadow: var(--shadow); }
        header { margin-bottom: 30px; text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 20px; }
        h1 { font-size: 2.2rem; margin-bottom: 10px; color: var(--primary-color); font-weight: 600; }
        .description { font-size: 1.05rem; color: #6c757d; max-width: 950px; margin: 0 auto 20px auto; }

        /* --- Conceptual Framework Section --- */
        .conceptual-framework {
            background-color: #eef4ff; /* Light blue background */
            border: 1px solid #a8c7fa;
            border-radius: var(--border-radius);
            padding: 20px 25px;
            margin-bottom: 30px;
        }
        .conceptual-framework h2 {
            color: var(--primary-color);
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 1px solid #cddcff;
            padding-bottom: 10px;
            font-weight: 600;
        }
        .conceptual-framework p {
            margin-bottom: 10px;
            font-size: 1rem;
            color: #334;
        }
        .conceptual-framework strong, .conceptual-framework .concept { /* Added .concept class */
             font-weight: 600;
             color: #1a237e; /* Darker blue */
        }
        .conceptual-framework ul { list-style-position: inside; padding-left: 5px; margin-top: 5px;}
        .conceptual-framework li { margin-bottom: 5px;}

        /* --- Control Panel --- */
        .control-panel { background-color: #fdfdfd; border-radius: var(--border-radius); border: 1px solid var(--border-color); padding: 20px; margin-bottom: 30px; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 25px; align-items: start; }
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .control-group label { font-weight: 500; margin-bottom: 3px; color: #495057; font-size: 0.9rem; }
        .input-group { display: flex; gap: 10px; }
        input, select, button { padding: 8px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius); font-size: 0.95rem; height: 38px; }
        input[type="text"], input[type="number"] { flex-grow: 1; }
        input:focus, select:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.15); }
        button { background-color: var(--primary-color); color: white; border: none; cursor: pointer; transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; font-weight: 500; min-width: 90px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); }
        button:hover { background-color: #3367D6; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        button:disabled { background-color: #aaa; cursor: not-allowed; box-shadow: none; }
        #range-hint { margin-top: 5px; font-size: 0.8rem; color: #6c757d; }

        /* --- Visualization Layout --- */
        .visualization-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 30px; margin-bottom: 30px; }
        .view-container { border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden; background: white; display: flex; flex-direction: column; }
        .view-header { display: flex; justify-content: space-between; align-items: center; background-color: #f8f9fa; padding: 10px 15px; border-bottom: 1px solid var(--border-color); }
        .view-info { flex-grow: 1; border-left: 5px solid var(--primary-color); padding-left: 10px; }
        .view-info h3 { margin-bottom: 5px; font-size: 1.1rem; font-weight: 600; }
        .view-info p { margin-bottom: 3px; font-size: 0.85rem; color: #495057;}
        .view-info .axis-desc { font-weight: 600; color: #333;} /* Style for axis descriptions */
        .view-controls { display: flex; gap: 10px; font-size: 0.8rem;}
        .view-controls label { margin-right: 3px;}
        .view-controls select { padding: 2px 4px; height: auto; font-size: 0.8rem; }
        .view-header.isg .view-info { border-left-color: var(--primary-color); }
        .view-header.dfg .view-info { border-left-color: var(--secondary-color); }
        .view-header.omegaomega .view-info { border-left-color: var(--tertiary-color); }
        .view-header.combined .view-info { border-left-color: var(--quaternary-color); }
        .stats-display { font-size: 0.8rem; padding: 5px 15px; background-color: #e9f2ff; border-bottom: 1px solid var(--border-color);}
        .stats-display p { margin: 2px 0; }
        .visualization-container { width: 100%; min-height: 400px; height: 50vh; max-height: 550px; overflow: hidden; position: relative; background-color: white; }
        .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.1rem; color: #6c757d; display: none; z-index: 10; }

        /* --- Factor Panel --- */
        .factor-panel { margin-top: 30px; padding: 25px; background-color: white; border-radius: var(--border-radius); border: 1px solid var(--border-color); }
        .factor-panel h2 { margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; font-size: 1.5rem; font-weight: 600; }
        #factor-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; }
        .factor-group { background-color: #f8f9fa; padding: 15px; border-radius: var(--border-radius); border: 1px solid #eee; }
        .factor-group h3 { margin-bottom: 10px; font-size: 1.1rem; font-weight: 600; color: var(--primary-color); }
        .factor-group p { margin-bottom: 8px; font-size: 0.95rem; }
        .sup { vertical-align: super; font-size: smaller; }

        /* --- Mathematical Insights Section --- */
        .insights-section { margin-top: 40px; padding: 25px; background-color: #f1f3f5; border-radius: var(--border-radius); border: 1px solid var(--border-color); }
        .insights-section h2 { font-size: 1.6rem; color: var(--dark-text); margin-bottom: 20px; border-bottom: 1px solid #ced4da; padding-bottom: 10px; font-weight: 600; }
        details { background: white; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 15px; padding: 15px; transition: box-shadow 0.2s ease; }
        details[open] { box-shadow: 0 3px 8px rgba(0, 0, 0, 0.06); }
        summary { font-weight: 600; font-size: 1.1rem; cursor: pointer; color: var(--primary-color); list-style: none; position: relative; padding-left: 25px; }
        summary::-webkit-details-marker { display: none; } summary::marker { display: none; }
        summary::before { content: '►'; position: absolute; left: 0; top: 0px; font-size: 0.9em; color: var(--primary-color); transition: transform 0.2s ease; }
        details[open] summary::before { transform: rotate(90deg); }
        .insight-content { margin-top: 15px; padding-left: 25px; border-left: 2px solid #e0e0e0; }
        .insight-content h4 { margin-top: 15px; margin-bottom: 5px; font-size: 1rem; color: #333; font-weight: 600; }
        .insight-content p { margin-bottom: 10px; font-size: 0.95rem; line-height: 1.7; }
        .insight-content code { background-color: #e9ecef; padding: 2px 5px; border-radius: 4px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; }
        .emphasis { font-style: italic; color: #555; }
        .view-ref { font-weight: bold; font-size: 0.9em; color: #666; display: block; margin-bottom: 10px; }
        .concept-highlight { font-weight: bold; color: var(--secondary-color); } /* Style for conceptual terms */

        /* --- Responsive --- */
        @media (max-width: 1200px) { .visualization-grid { grid-template-columns: 1fr; } .visualization-container { height: 45vh; min-height: 350px; } }
        @media (max-width: 768px) { h1 { font-size: 1.8rem; } .description { font-size: 1rem; } .control-panel { grid-template-columns: 1fr; } #factor-details { grid-template-columns: 1fr; } .insights-section h2 { font-size: 1.4rem; } summary { font-size: 1rem; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Integer Prime Structure Visualizer</h1>
            <p class="description">
                Explore the structure of integers via their prime factorizations. Map integers to coordinates based on exponent patterns (Intensity, Volume, Variety) revealing mathematical relationships, statistical distributions, and connections to number theory concepts like ζ(s) and λ(n). Includes 2D views and a combined 3D perspective.
            </p>
        </header>

        <!-- Conceptual Framework -->
        <section class="conceptual-framework">
            <h2>Conceptual Framework: Numbers as Relational Structures</h2>
            <p>This visualizer explores integers not just as quantities, but as unique structures defined by their prime factorization (e.g., 12 = 2² × 3¹). Think of each integer as a specific <span class="concept">"Pattern of Relatedness"</span> built from prime components.</p>
            <p>The core structural aspects derived from the factorization's exponents (e.g., the '2' and '1' for 12) are:</p>
            <ul>
                <li><span class="concept">Variety</span> (`ω(n)`): The number of <strong>unique prime things</strong> it's made of.</li>
                <li><span class="concept">Relative Mix/Pattern</span> (`{eᵢ}`): How many times each unique thing is used/stacked. Key summary:
                    <ul><li><strong>Peak Usage</strong> (`max{eᵢ}`): The highest stack height for any single prime type.</li></ul>
                </li>
                <li><span class="concept">Overall Structural Size</span> (`Ω(n)`): The grand total count of prime factors (Σeᵢ), reflecting both variety and usage pattern.</li>
            </ul>
            <p>The different visualization views map these structures by comparing pairs of these aspects, revealing <span class="concept">"meta-relationships"</span> – the underlying rules and patterns connecting different integer structures.</p>
        </section>


        <!-- Control Panel -->
        <div class="control-panel">
             <!-- Controls remain the same -->
             <div class="control-group"> <label for="integer-input">Integer(s) Range:</label> <div class="input-group"> <input type="text" id="integer-input" placeholder="e.g. 1-100" value="1-100"> <button id="visualize-btn">Visualize</button> </div> <div id="range-hint">Range (e.g., 1-1000). Max: 5000.</div> </div>
             <div class="control-group"> <label for="highlight-input">Highlight Integer (Click Point or Enter):</label> <input type="number" id="highlight-input" min="1" placeholder="e.g. 12" value="12"> </div>
             <div class="control-group"> <label for="special-category">Highlight Category:</label> <select id="special-category"> <option value="none">None</option> <option value="primes">Prime Numbers</option> <option value="prime-powers">Prime Powers (p^k, k>=1)</option> <option value="perfect-squares">Perfect Squares</option> <option value="square-free">Square-free Numbers</option> <option value="perfect">Perfect Numbers</option> <option value="abundant">Abundant Numbers</option> <option value="deficient">Deficient Numbers</option> </select> </div>
             <div class="control-group"> <label for="color-mode">Point Color Mode:</label> <select id="color-mode"> <option value="default">Default by View</option> <option value="lambda">By Liouville Function λ(n)</option> </select> </div>
        </div>

        <!-- Visualization Grid Layout -->
        <div class="visualization-grid">
             <!-- ISG View -->
             <div class="view-container">
                <div class="view-header isg">
                    <div class="view-info isg">
                        <h3>ISG (Peak Usage vs. Size)</h3>
                        <p><span class="axis-desc">X: Peak Usage</span> (Max Exponent)</p>
                        <p><span class="axis-desc">Y: Structural Size</span> (Total Factors Ω(n))</p>
                    </div>
                    <div class="view-controls"> <label for="isg-x-scale">X:</label><select id="isg-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> <label for="isg-y-scale">Y:</label><select id="isg-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> </div>
                </div>
                <div id="isg-stats" class="stats-display">Statistics loading...</div>
                <div id="isg-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
             </div>
             <!-- DFG View -->
             <div class="view-container">
                 <div class="view-header dfg">
                     <div class="view-info dfg">
                        <h3>DFG (Variety vs. Peak Usage)</h3>
                        <p><span class="axis-desc">X: Variety</span> (Distinct Factors ω(n))</p>
                        <p><span class="axis-desc">Y: Peak Usage</span> (Max Exponent)</p>
                    </div>
                     <div class="view-controls"> <label for="dfg-x-scale">X:</label><select id="dfg-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> <label for="dfg-y-scale">Y:</label><select id="dfg-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> </div>
                 </div>
                 <div id="dfg-stats" class="stats-display">Statistics loading...</div>
                 <div id="dfg-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
             </div>
             <!-- OmegaOmega View -->
             <div class="view-container">
                  <div class="view-header omegaomega">
                     <div class="view-info omegaomega">
                        <h3>OO (Variety vs. Size)</h3>
                        <p><span class="axis-desc">X: Variety</span> (Distinct Factors ω(n))</p>
                        <p><span class="axis-desc">Y: Structural Size</span> (Total Factors Ω(n))</p>
                    </div>
                     <div class="view-controls"> <label for="omegaomega-x-scale">X:</label><select id="omegaomega-x-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> <label for="omegaomega-y-scale">Y:</label><select id="omegaomega-y-scale" class="axis-scale"><option value="linear">Lin</option><option value="log">Log</option></select> </div>
                 </div>
                 <div id="omegaomega-stats" class="stats-display">Statistics loading...</div>
                 <div id="omegaomega-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
             </div>
             <!-- Combined 3D View -->
             <div class="view-container">
                  <div class="view-header combined">
                     <div class="view-info combined">
                        <h3>Combined 3D</h3>
                        <p><span class="axis-desc">X: Variety</span> (ω(n))</p>
                        <p><span class="axis-desc">Y: Peak Usage</span> (Max Exp)</p>
                        <p><span class="axis-desc">Z: Structural Size</span> (Ω(n))</p>
                    </div>
                 </div>
                 <div id="combined-stats" class="stats-display">(3D View)</div>
                 <div id="combined-visualization" class="visualization-container"> <div class="loader">Initializing...</div> </div>
             </div>
        </div>

        <!-- Mathematical Insights Section -->
        <section class="insights-section">
            <h2>Mathematical Insights & Interpretations</h2>

             <details>
                 <summary>Transformational: Exponentiation & Scaling Rays</summary>
                 <div class="insight-content">
                     <span class="view-ref">Most apparent in: ISG View (Peak Usage vs. Size)</span>
                     <h4>Property:</h4> <p>If <code>m</code> maps to <code>(Peak_m, Size_m)</code>, then <code>m^k</code> maps to <code>(k * Peak_m, k * Size_m)</code>.</p>
                     <h4>Result:</h4> <p>Powers <code>m, m², m³, ...</code> form straight rays from (0,0) on the ISG plot.</p>
                     <h4>Interpretation:</h4> <p class="emphasis">The arithmetic act of exponentiation (intensifying the 'Pattern of Relatedness') corresponds directly to geometric scaling in this view. The rays visualize this <strong class="concept-highlight">transformational meta-relationship</strong>.</p>
                 </div>
             </details>

              <details>
                 <summary>Affinity: Liouville Function λ(n) & Parity</summary>
                 <div class="insight-content">
                     <span class="view-ref">Apparent in: ISG, OO Views (Y-axis = Size Ω(n)); Explicit in Lambda Color Mode</span>
                     <h4>Property:</h4> <p><code>λ(n) = (-1)^Ω(n)</code>. The Y-coordinate in ISG/OO is <code>y = Ω(n)</code>.</p>
                     <h4>Result:</h4> <p>All integers on the same horizontal line <code>y = k</code> in ISG/OO share the same <code>λ(n) = (-1)^k</code> value (same parity of total factors). Lambda color mode directly shows this grouping.</p>
                     <h4>Interpretation:</h4> <p class="emphasis">The grid structure inherently groups Patterns by the parity of their total 'Structural Size' (Ω). This reveals an <strong class="concept-highlight">affinity meta-relationship</strong> between the grid layout and this fundamental number property.</p>
                 </div>
             </details>

              <details>
                 <summary>Combinatorial: Multiplication Rules</summary>
                 <div class="insight-content">
                     <span class="view-ref">Relevant to all views, effects vary.</span>
                      <h4>Property:</h4> <p>If <code>n = a * b</code>:</p>
                      <ul>
                         <li>'Structural Size' (Ω): Always additive: <code>Ω(n) = Ω(a) + Ω(b)</code>.</li>
                         <li>'Variety' (ω): Additive only if <code>a, b</code> are coprime.</li>
                         <li>'Peak Usage' (Max Exp): Complex interaction; <code>max_exp(n) = max_p{v_p(a) + v_p(b)}</code>, which simplifies to <code>max(max_exp(a), max_exp(b))</code> only if <code>a, b</code> are coprime.</li>
                      </ul>
                      <h4>Interpretation:</h4> <p class="emphasis">These rules show the <strong class="concept-highlight">combinatorial meta-relationships</strong>. 'Structural Size' (Ω) combines simply, while 'Variety' (ω) and 'Peak Usage' (Max Exp) interact more complexly, revealing how "Patterns of Relatedness" combine under multiplication.</p>
                  </div>
              </details>

              <details>
                 <summary>Relational Shape: Structural Spread & Contours</summary>
                 <div class="insight-content">
                      <span class="view-ref">Apparent in: ISG View, OmegaOmega View</span>
                      <h4>Property:</h4>
                      <ul>
                         <li>ISG Spread: <code>d₁ = Ω(n) - max{eᵢ}</code> ('Size' - 'Peak Usage'). <code>d₁=0</code> for prime powers (<code>y=x</code> line).</li>
                          <li>OO Spread (Repetition): <code>d₂ = Ω(n) - ω(n)</code> ('Size' - 'Variety'). <code>d₂=0</code> for square-free (<code>y=x</code> line).</li>
                      </ul>
                      <h4>Result:</h4> <p>Lines where <code>d₁</code> (ISG) or <code>d₂</code> (OO) are constant run parallel to the <code>y=x</code> diagonal in those plots.</p>
                      <h4>Interpretation:</h4> <p class="emphasis">These differences quantify the <strong class="concept-highlight">relational shape meta-relationship</strong>, measuring the internal balance or spread of the Pattern. Contours group structures with similar shapes (peaked vs. spread in ISG; repetitive vs. non-repetitive in OO).</p>
                  </div>
              </details>

              <details>
                 <summary>Statistical: Density, Distribution & ζ(s)</summary>
                 <div class="insight-content">
                      <span class="view-ref">Apparent in: DFG View (Variety vs. Peak Usage)</span>
                      <h4>Property & Result:</h4>
                      <ul>
                          <li>Numbers with 'Peak Usage' <code>max{eᵢ} <= m</code> are (m+1)-free.</li>
                          <li>In DFG, these correspond to the region <code>Y <= m</code>.</li>
                          <li>Asymptotic density of (m+1)-free numbers is <code>1/ζ(m+1)</code>.</li>
                          <li>Specifically, Square-Free (<code>Y=1</code> region) density ≈ <code>1/ζ(2)</code>. Cube-Free (<code>Y<=2</code> region) density ≈ <code>1/ζ(3)</code>.</li>
                      </ul>
                      <p>The DFG statistics compare actual vs. theoretical densities.</p>
                      <h4>Interpretation:</h4> <p class="emphasis">Reveals a <strong class="concept-highlight">statistical meta-relationship</strong>. The DFG layout directly reflects fundamental constants (ζ values) governing the global distribution of integers based on their 'Peak Usage' limits (power-freeness). The distribution along the X-axis ('Variety' ω) also connects to the Erdős–Kac theorem's `log(log N)` behavior.</p>
                  </div>
              </details>

        </section>


        <!-- Factor Panel -->
        <div class="factor-panel">
            <h2>Integer Analysis</h2>
            <div id="factor-details" class="factor-details">
                 <div class="factor-group"><h3>Information Panel</h3><p>Click a point or enter an integer above.</p></div>
            </div>
        </div>
    </div>

    <script>
        // ----- CONSTANTS -----
        const ZETA_VALUES = { 2: 1.644934, 3: 1.202057, 4: 1.082323, 5: 1.036928 };
        const MAX_RANGE_LIMIT = 5000;

        // ----- CORE MATH FUNCTIONS -----
        const factorizationCache = new Map();
        function getPrimeFactorization(n) { /* ... No changes ... */
             if (n <= 0 || !Number.isInteger(n)) { throw new Error("Input must be a positive integer"); }
             if (factorizationCache.has(n)) { return factorizationCache.get(n); }
             if (n === 1) { factorizationCache.set(1, {}); return {}; }
             const factors = {}; let num = n;
             while (num % 2 === 0) { factors[2] = (factors[2] || 0) + 1; num /= 2; }
             for (let i = 3; i * i <= num; i += 2) { while (num % i === 0) { factors[i] = (factors[i] || 0) + 1; num /= i; } }
             if (num > 1) { factors[num] = (factors[num] || 0) + 1; }
             factorizationCache.set(n, factors); return factors;
        }

        const propertiesCache = new Map();
        function calculateProperties(n) { /* ... No changes ... */
            if (propertiesCache.has(n)) { return propertiesCache.get(n); }
            if (n === 1) { const props = { n: 1, factorization: {}, isg: [0, 0], dfg: [0, 0], omegaomega: [0, 0], omega: 0, Omega: 0, maxExp: 0, lambda: 1, sigma: 1, d: 1, isPrime: false, isPrimePower: false, isSquareFree: true, isPerfectSquare: true, isPerfect: false, isAbundant: false, isDeficient: false }; propertiesCache.set(1, props); return props; }
            const factorization = getPrimeFactorization(n);
            const exponents = Object.values(factorization); const primes = Object.keys(factorization).map(Number);
            const distinctFactors = primes.length; const maxExponent = exponents.length > 0 ? Math.max(...exponents) : 0; const totalFactors = exponents.reduce((s, e) => s + e, 0);
            let numDivisors = 1; let sumDivisors = 1;
            for (let i = 0; i < primes.length; i++) { const p = primes[i]; const e = exponents[i]; numDivisors *= (e + 1); sumDivisors *= (Math.pow(p, e + 1) - 1) / (p - 1); }
            const lambda = (totalFactors % 2 === 0) ? 1 : -1;
            const isPrime = distinctFactors === 1 && maxExponent === 1; const isPrimePower = distinctFactors === 1 && totalFactors >= 1;
            const isSquareFree = maxExponent <= 1; const isPerfectSquare = exponents.every(e => e % 2 === 0);
            const sigma_minus_2n = sumDivisors - 2 * n; const isPerfect = sigma_minus_2n === 0; const isAbundant = sigma_minus_2n > 0; const isDeficient = sigma_minus_2n < 0;
            const props = { n, factorization, isg: [maxExponent, totalFactors], dfg: [distinctFactors, maxExponent], omegaomega: [distinctFactors, totalFactors], omega: distinctFactors, Omega: totalFactors, maxExp: maxExponent, lambda, sigma: sumDivisors, d: numDivisors, isPrime, isPrimePower, isSquareFree, isPerfectSquare, isPerfect, isAbundant, isDeficient };
            propertiesCache.set(n, props); return props;
        }

        function generateIntegerRange(input) { /* ... No changes ... */
             input = input.trim(); if (!input) throw new Error("Input cannot be empty.");
             if (input.includes('-')) {
                 const parts = input.split('-'); if (parts.length !== 2) throw new Error("Invalid range format.");
                 const start = parseInt(parts[0].trim()); const end = parseInt(parts[1].trim());
                 if (isNaN(start) || isNaN(end) || start < 1 || end < start) { throw new Error("Invalid range values."); }
                 if (end - start + 1 > MAX_RANGE_LIMIT) { throw new Error(`Range too large (max ${MAX_RANGE_LIMIT}).`); }
                 return Array.from({length: end - start + 1}, (_, i) => start + i);
             } else { const n = parseInt(input); if (isNaN(n) || n < 1) { throw new Error("Invalid integer."); } return [n]; }
        }

        // ----- UI & INFO PANEL FUNCTIONS -----
        function formatFactorizationHTML(factorization) { /* ... No changes ... */
             if (Object.keys(factorization).length === 0) return "1"; return Object.entries(factorization) .sort((a, b) => parseInt(a[0]) - parseInt(b[0])) .map(([p, e]) => e === 1 ? p : `${p}<span class="sup">${e}</span>`).join(" &times; ");
        }
        function updateFactorInfo(n) { /* ... No changes ... */
            const factorDetails = document.getElementById("factor-details"); try { if (isNaN(n) || n < 1) { factorDetails.innerHTML = `<div class="factor-group"><h3>Info Panel</h3><p>Enter valid integer or click point.</p></div>`; return; } const props = propertiesCache.get(n); if (!props) { factorDetails.innerHTML = `<div class="factor-group"><h3>Integer: ${n}</h3><p>Data not calculated.</p></div>`; return; } let specialPropsText = []; if (props.isPrime) specialPropsText.push("Prime"); else if (props.isPrimePower && n > 1) specialPropsText.push("Prime Power"); if (props.isPerfectSquare && n > 1) specialPropsText.push("Perfect Square"); if (props.isSquareFree && !props.isPrime && n > 1) specialPropsText.push("Square-free Composite"); else if (props.isSquareFree && n === 1) specialPropsText.push("Square-free"); let divisorPropsText = ""; if (props.isPerfect && n > 1) divisorPropsText = "Perfect"; else if (props.isAbundant) divisorPropsText = "Abundant"; else if (props.isDeficient || n === 1) divisorPropsText = "Deficient"; if(divisorPropsText) specialPropsText.push(divisorPropsText + ` (σ(n)=${props.sigma})`); factorDetails.innerHTML = ` <div class="factor-group"> <h3>Integer: ${props.n}</h3> <p><strong>Factorization:</strong> ${formatFactorizationHTML(props.factorization)}</p> <p><strong>Properties:</strong> ${specialPropsText.length ? specialPropsText.join(", ") : (n === 1 ? "Unit" : "Composite")}</p> </div> <div class="factor-group"> <h3>Coordinates</h3> <p><strong>ISG (MaxExp, Ω):</strong> (${props.isg.join(", ")})</p> <p><strong>DFG (ω, MaxExp):</strong> (${props.dfg.join(", ")})</p> <p><strong>OO (ω, Ω):</strong> (${props.omegaomega.join(", ")})</p> </div> <div class="factor-group"> <h3>Metrics</h3> <p><strong>ω(n) (Distinct):</strong> ${props.omega}</p> <p><strong>Ω(n) (Total):</strong> ${props.Omega}</p> <p><strong>Max Exponent:</strong> ${props.maxExp}</p> <p><strong>λ(n) (Liouville):</strong> ${props.lambda}</p> <p><strong>d(n) (Divisors):</strong> ${props.d}</p> <p><strong>σ(n) (Sum Divisors):</strong> ${props.sigma}</p> </div>`; } catch (error) { console.error("Error updating factor info:", error); factorDetails.innerHTML = `<div class="factor-group"><h3>Error</h3><p>Could not display info for ${n}. ${error.message}</p></div>`; }
        }

        // ----- STATISTICS CALCULATION -----
        function calculateAndDisplayStats(processedData, N) { /* ... No changes ... */
             if (!processedData || processedData.length === 0) { document.getElementById('isg-stats').textContent = "No data."; document.getElementById('dfg-stats').textContent = "No data."; document.getElementById('omegaomega-stats').textContent = "No data."; document.getElementById('combined-stats').textContent = "(3D View)"; return; } const count = processedData.length; const omegaValues = processedData.map(d => d.omega); const maxExpValues = processedData.map(d => d.maxExp); const actualSqFree = processedData.filter(d => d.isSquareFree).length; const actualCubeFree = processedData.filter(d => d.maxExp <= 2).length; const densitySqFree = (actualSqFree / count * 100).toFixed(1); const densityCubeFree = (actualCubeFree / count * 100).toFixed(1); const theoreticalSqFree = (1 / ZETA_VALUES[2] * 100).toFixed(1); const theoreticalCubeFree = (1 / ZETA_VALUES[3] * 100).toFixed(1); const meanOmega = omegaValues.reduce((s, v) => s + v, 0) / count; const stdDevOmega = Math.sqrt(omegaValues.reduce((s, v) => s + (v - meanOmega)**2, 0) / count); const theoreticalMeanOmega = N > 2 ? Math.log(Math.log(N)) : 0; const dfgStatsHtml = ` <p title="Density of numbers n where max exponent in factorization is <= 1. Theoretical ≈ 1/ζ(2)">Sq-Free (Act: ${densitySqFree}%, Th: ${theoreticalSqFree}%) | <span title="Density where max exponent <= 2. Theoretical ≈ 1/ζ(3)">Cube-Free (Act: ${densityCubeFree}%, Th: ${theoreticalCubeFree}%)</span></p> <p title="Average number of distinct prime factors ω(n). Theoretical ≈ log(log(N)) by Erdős–Kac.">ω(n) Avg (Act: ${meanOmega.toFixed(2)}, Th: ${theoreticalMeanOmega.toFixed(2)}) | StdDev (Act: ${stdDevOmega.toFixed(2)}, Th: ${theoreticalMeanOmega > 0 ? Math.sqrt(theoreticalMeanOmega).toFixed(2) : 'N/A'})</p> `; document.getElementById('dfg-stats').innerHTML = dfgStatsHtml; const isgStatsHtml = ` <p>Total Points: ${count}. Avg Ω(n): ${(processedData.reduce((s, d) => s + d.Omega, 0) / count).toFixed(2)}.</p> `; const ooStatsHtml = ` <p>ω(n) Avg (Act: ${meanOmega.toFixed(2)}, Th: ${theoreticalMeanOmega.toFixed(2)}) | StdDev (Act: ${stdDevOmega.toFixed(2)}, Th: ${theoreticalMeanOmega > 0 ? Math.sqrt(theoreticalMeanOmega).toFixed(2) : 'N/A'})</p> `; document.getElementById('isg-stats').innerHTML = isgStatsHtml; document.getElementById('omegaomega-stats').innerHTML = ooStatsHtml; document.getElementById('combined-stats').innerHTML = `(3D View - ${count} points)`;
        }

        // ----- PLOTLY VISUALIZATION -----
        const viewConfigs = { /* ... No changes ... */
             isg: { type: 'scatter', x: 'isg[0]', y: 'isg[1]', xLabel: 'Max Exp', yLabel: 'Total Ω(n)', color: 'var(--primary-color)', containerId: 'isg-visualization', statsId: 'isg-stats' },
             dfg: { type: 'scatter', x: 'dfg[0]', y: 'dfg[1]', xLabel: 'Distinct ω(n)', yLabel: 'Max Exp', color: 'var(--secondary-color)', containerId: 'dfg-visualization', statsId: 'dfg-stats' },
             omegaomega: { type: 'scatter', x: 'omegaomega[0]', y: 'omegaomega[1]', xLabel: 'Distinct ω(n)', yLabel: 'Total Ω(n)', color: 'var(--tertiary-color)', containerId: 'omegaomega-visualization', statsId: 'omegaomega-stats' },
             combined: { type: 'scatter3d', x: 'omega', y: 'maxExp', z: 'Omega', xLabel: 'Distinct ω(n)', yLabel: 'Max Exp', zLabel: 'Total Ω(n)', color: 'var(--quaternary-color)', containerId: 'combined-visualization', statsId: 'combined-stats' }
        };
        function getNestedValue(obj, path) { /* ... No changes ... */ if (!path) return undefined; const keys = path.replace(/\[(\d+)\]/g, '.$1').split('.'); let v = obj; for (const k of keys) { if (v === undefined || v === null) return undefined; v = v[k]; } return v;}

        function getPlotAnnotationsAndShapes(view, processedData) { /* ... No changes ... */
             const shapes = []; const annotations = []; if (!processedData || processedData.length === 0) return { shapes, annotations }; const xData = processedData.map(d => getNestedValue(d, viewConfigs[view].x)); const yData = processedData.map(d => getNestedValue(d, viewConfigs[view].y)); const maxX = Math.max(...xData, 0); const maxY = Math.max(...yData, 0); const maxDim = Math.max(maxX, maxY, 1); const lineStyle = { type: 'line', line: { color: 'rgba(0,0,0,0.3)', width: 1, dash: 'dot' }, layer: 'below' }; const annoStyle = { showarrow: false, font: { size: 10, color: 'grey'}, bgcolor: 'rgba(255,255,255,0.6)', xanchor: 'left', yanchor: 'bottom' }; switch (view) { case 'isg': shapes.push({ ...lineStyle, x0: 0, y0: 0, x1: maxDim, y1: maxDim }); annotations.push({ ...annoStyle, x: maxDim*0.95, y: maxDim*0.95, text: 'y=x (p^k)'}); if (maxX > 0 && maxY > 0) { annotations.push({ ...annoStyle, x: maxX * 0.8, y: maxY * 0.1, text: 'Void (y<x)'}); } break; case 'dfg': shapes.push({ ...lineStyle, type: 'line', x0: 1, y0: 0, x1: 1, y1: maxY + 0.5 }); annotations.push({ ...annoStyle, x: 1.05, y: maxY * 0.95, text: 'ω=1 (p^k)'}); shapes.push({ type: 'rect', x0: 0.5, y0: -0.5, x1: 1.5, y1: maxY + 0.5, fillcolor: 'rgba(0,100,0,0.03)', layer: 'below', line: {width: 0} }); annotations.push({ ...annoStyle, x: 0.6, y: maxY * 0.1, text: 'Sq-Free (Y=1)'}); break; case 'omegaomega': shapes.push({ ...lineStyle, x0: 1, y0: 1, x1: maxDim, y1: maxDim }); annotations.push({ ...annoStyle, x: maxDim*0.95, y: maxDim*0.95, text: 'y=x (Sq-Free)'}); break; } return { shapes, annotations };
        }

        function createOrUpdateVisualization(view, processedData) { /* ... No changes ... */
            const config = viewConfigs[view]; const plotDiv = document.getElementById(config.containerId); const loader = plotDiv.querySelector('.loader'); loader.style.display = 'block';
            const xData = processedData.map(d => getNestedValue(d, config.x)); const yData = processedData.map(d => getNestedValue(d, config.y)); const zData = config.z ? processedData.map(d => getNestedValue(d, config.z)) : undefined;
            const colorMode = document.getElementById('color-mode').value;
            let baseMarkerColors; if (colorMode === 'lambda') { baseMarkerColors = processedData.map(d => d.lambda === 1 ? 'var(--lambda-pos-color)' : 'var(--lambda-neg-color)'); } else { baseMarkerColors = new Array(processedData.length).fill(config.color); }
            appData.currentColors[view] = baseMarkerColors; // Store base colors

            const trace = { x: xData, y: yData, mode: 'markers', type: config.type,
                text: processedData.map(d => { let c = config.z?`${d.omega},${d.maxExp},${d.Omega}`:`${getNestedValue(d, config.x)},${getNestedValue(d, config.y)}`; return `n=${d.n}<br>Coords:(${c})<br>λ(n):${d.lambda}`; }),
                hoverinfo: 'text', marker: { size: appData.markerSizes[view], color: baseMarkerColors, opacity: appData.markerOpacities[view], line: { color: 'rgba(0,0,0,0.3)', width: 0.5 } },
                customdata: processedData.map(d => d.n) };
            if (config.type === 'scatter3d') { trace.z = zData; }

            const xScaleType = document.getElementById(`${view}-x-scale`)?.value || 'linear'; const yScaleType = document.getElementById(`${view}-y-scale`)?.value || 'linear';
            const layout = { title: `${view.toUpperCase()} View`, hovermode: 'closest', margin: { l: 60, r: 30, b: 60, t: 80 }, autosize: true, paper_bgcolor: 'white', plot_bgcolor: 'white' };
            if (config.type === 'scatter3d') { layout.scene = { xaxis:{title:config.xLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'}, yaxis:{title:config.yLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'}, zaxis:{title:config.zLabel, type:'linear', backgroundcolor:"rgba(0,0,0,0)", gridcolor:"#ddd", zerolinecolor:"#ccc", rangemode:'tozero'}, aspectratio:{x:1,y:1,z:0.8} }; layout.margin = {l:10,r:10,b:10,t:50}; }
            else { layout.xaxis = {title:config.xLabel, type:xScaleType, zeroline:false, gridcolor:'#eee', rangemode:'tozero'}; layout.yaxis = {title:config.yLabel, type:yScaleType, zeroline:false, gridcolor:'#eee', rangemode:'tozero'}; const { shapes, annotations } = getPlotAnnotationsAndShapes(view, processedData); layout.shapes = shapes; layout.annotations = annotations; }

            Plotly.react(plotDiv, [trace], layout, {responsive: true}).then(() => {
                 loader.style.display = 'none'; const plotElement = document.getElementById(config.containerId);
                 if (plotElement) { plotElement.removeAllListeners('plotly_click'); plotElement.on('plotly_click', function(data) { if (data.points.length > 0) { const clickedN = data.points[0].customdata; document.getElementById('highlight-input').value = clickedN; updateFactorInfo(clickedN); highlightInteger(clickedN); } }); }
             }).catch(err => { console.error(`Plotly error for view ${view}:`, err); loader.textContent = 'Error rendering plot.'; });
        }

        function highlightInteger(n) { /* ... No changes ... */
             if (isNaN(n) || n < 1) n = -1; const hlMkr = { color: '#FF0000', sizeFactor: 1.5, line: { color: '#000000', width: 2 }, opacity: 1 }; const hlMkr3D = { color: '#FF0000', sizeFactor: 1.5, opacity: 1 };
             Object.entries(viewConfigs).forEach(([view, config]) => { const plotDiv = document.getElementById(config.containerId); if (plotDiv && plotDiv.data && plotDiv.data.length > 0 && appData.markerSizes[view]) { const traceIndex = 0; const trace = plotDiv.data[traceIndex]; if (!trace || !trace.customdata) return; const baseSizes = appData.markerSizes[view]; const baseOpacities = appData.markerOpacities[view]; const baseColors = appData.currentColors ? [...appData.currentColors[view]] : new Array(trace.customdata.length).fill(config.color); const sizes = [...baseSizes]; const opacities = [...baseOpacities]; const lineColors = new Array(trace.customdata.length).fill('rgba(0,0,0,0.3)'); const lineWidths = new Array(trace.customdata.length).fill(0.5); const markerColors = [...baseColors]; let needsRestyle = false; if (n !== -1) { trace.customdata.forEach((val, index) => { if (val === n) { needsRestyle = true; const hl = config.type === 'scatter3d' ? hlMkr3D : hlMkr; markerColors[index] = hl.color; sizes[index] = baseSizes[index] * hl.sizeFactor; opacities[index] = hl.opacity; if (hl.line) { lineColors[index] = hl.line.color; lineWidths[index] = hl.line.width; } } }); } else { needsRestyle = true; } if (needsRestyle) { Plotly.restyle(plotDiv, { 'marker.color': [markerColors], 'marker.size': [sizes], 'marker.opacity': [opacities], 'marker.line.color': [lineColors], 'marker.line.width': [lineWidths] }, traceIndex); } } });
        }

        function highlightCategory(category) { /* ... No changes ... */
            if (!appData.processedData || appData.processedData.length === 0) return; const highlightOpacity = 0.95; const dimOpacity = 0.15; let filterFn; switch(category) { case "primes": filterFn = d => d.isPrime; break; case "prime-powers": filterFn = d => d.isPrimePower; break; case "perfect-squares": filterFn = d => d.isPerfectSquare; break; case "square-free": filterFn = d => d.isSquareFree; break; case "perfect": filterFn = d => d.isPerfect; break; case "abundant": filterFn = d => d.isAbundant; break; case "deficient": filterFn = d => d.isDeficient; break; default: filterFn = d => true; } const highlightIndices = new Set(); appData.processedData.forEach((d, i) => { if (filterFn(d)) { highlightIndices.add(i); } }); Object.entries(viewConfigs).forEach(([view, config]) => { const plotDiv = document.getElementById(config.containerId); if (plotDiv && plotDiv.data && plotDiv.data.length > 0 && appData.markerOpacities[view]) { const traceIndex = 0; const numPoints = plotDiv.data[traceIndex].customdata.length; const baseOpacities = appData.markerOpacities[view]; let opacities = new Array(numPoints); if (category === 'none') { opacities = [...baseOpacities]; highlightInteger(-1); } else { for(let i=0; i < numPoints; i++) { opacities[i] = highlightIndices.has(i) ? highlightOpacity : dimOpacity; } } Plotly.restyle(plotDiv, { 'marker.opacity': [opacities] }, traceIndex); } });
        }

        // ----- MAIN APPLICATION LOGIC -----
        let appData = { /* ... No changes ... */ integers: [], processedData: [], coordDensity: {}, markerSizes: {}, markerOpacities: {}, currentColors: {} };

        function processAndVisualize() { /* ... No changes ... */
            const visualizeBtn = document.getElementById('visualize-btn'); visualizeBtn.disabled = true; visualizeBtn.textContent = 'Processing...'; factorizationCache.clear(); propertiesCache.clear();
             Object.values(viewConfigs).forEach(config => { const plotDiv = document.getElementById(config.containerId); plotDiv.querySelector('.loader').style.display = 'block'; Plotly.purge(plotDiv); document.getElementById(config.statsId).innerHTML = "Calculating..."; });
            setTimeout(() => { try { const input = document.getElementById("integer-input").value; const integers = generateIntegerRange(input); const maxN = integers.length > 0 ? integers[integers.length - 1] : 0; appData.integers = integers; appData.processedData = integers.map(n => calculateProperties(n)); appData.coordDensity = {}; appData.markerSizes = {}; appData.markerOpacities = {}; appData.currentColors = {}; const colorMode = document.getElementById('color-mode').value; Object.keys(viewConfigs).forEach(view => { const config = viewConfigs[view]; appData.coordDensity[view] = {}; appData.processedData.forEach(d => { const ck = config.z ? `${d.omega},${d.maxExp},${d.Omega}` : `${getNestedValue(d, config.x)},${getNestedValue(d, config.y)}`; appData.coordDensity[view][ck] = (appData.coordDensity[view][ck] || 0) + 1; }); appData.markerSizes[view] = appData.processedData.map(d => { const ck = config.z ? `${d.omega},${d.maxExp},${d.Omega}` : `${getNestedValue(d, config.x)},${getNestedValue(d, config.y)}`; const cnt = appData.coordDensity[view][ck] || 1; return Math.min(config.type==='scatter3d'?10:15, config.type==='scatter3d'?3:5 + Math.sqrt(cnt)); }); appData.markerOpacities[view] = new Array(appData.processedData.length).fill(0.7); if (colorMode === 'lambda') { appData.currentColors[view] = appData.processedData.map(d => d.lambda === 1 ? 'var(--lambda-pos-color)' : 'var(--lambda-neg-color)'); } else { appData.currentColors[view] = new Array(appData.processedData.length).fill(config.color); } }); calculateAndDisplayStats(appData.processedData, maxN); Object.keys(viewConfigs).forEach(view => { createOrUpdateVisualization(view, appData.processedData); }); const category = document.getElementById("special-category").value; highlightCategory(category); const highlightN = parseInt(document.getElementById("highlight-input").value); updateFactorInfo(highlightN); highlightInteger(highlightN); } catch (error) { alert("Error: " + error.message); console.error(error); Object.values(viewConfigs).forEach(config => { const plotDiv = document.getElementById(config.containerId); if (plotDiv) plotDiv.querySelector('.loader').style.display = 'none'; }); } finally { visualizeBtn.disabled = false; visualizeBtn.textContent = 'Visualize'; } }, 10);
        }

        // --- EVENT LISTENERS ---
        document.getElementById("visualize-btn").addEventListener("click", processAndVisualize);
        document.getElementById("highlight-input").addEventListener("input", function() { const n = parseInt(this.value); updateFactorInfo(n); if (!isNaN(n) && n >= 1) highlightInteger(n); else highlightInteger(-1); });
        document.getElementById("special-category").addEventListener("change", function() { highlightCategory(this.value); });
        document.getElementById("color-mode").addEventListener("change", processAndVisualize); // Re-plot required
        document.querySelectorAll(".axis-scale").forEach(sel => sel.addEventListener("change", processAndVisualize)); // Re-plot required
        document.addEventListener("DOMContentLoaded", processAndVisualize);

    </script>
</body>
</html>
